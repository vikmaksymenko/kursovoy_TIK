<!DOCTYPE html>
<html><head>

   </head>
   <body>
    <h1 class="title">
		Алгоритм Хаффмана на пальцах
  	</h1>
  	

    <div class="content html_format">
Предположим, у нас есть строка «beep boop beer!», для которой, в её 
текущем виде, на каждый знак тратится по одному байту. Это означает, что
 вся строка целиком занимает 15*8 = 120 бит памяти. После кодирования 
строка займёт 40 бит (на практике, в нашей программе мы выведем на 
консоль последовательность из 40 нулей и единиц, представляющих собой 
биты кодированного текста. Чтобы получить из них настоящую строку 
размером 40 бит, нужно применять битовую арифметику, поэтому мы сегодня 
не будем этого делать).<br>
<br>
Чтобы лучше понять пример, мы для начала сделаем всё вручную. Строка 
«beep boop beer!» для этого очень хорошо подойдёт. Чтобы получить код 
для каждого символа на основе его частотности, нам надо построить 
бинарное дерево, такое, что каждый лист этого дерева будет содержать 
символ (печатный знак из строки). Дерево будет строиться от листьев к 
корню, в том смысле, что символы с меньшей частотой будут дальше от 
корня, чем символы с большей. Скоро вы увидите, для чего это нужно.<br>
<br>
Чтобы построить дерево, мы воспользуемся слегка модифицированной 
очередью с приоритетами — первыми из неё будут извлекаться элементы с 
наименьшим приоритетом, а не наибольшим. Это нужно, чтобы строить дерево
 от листьев к корню.<br>
<br>
Для начала посчитаем частоты всех символов:<br>
<table>
<tbody><tr>
<th>Символ</th>
<th>Частота</th>
</tr>
<tr>
<td>'b'</td>
<td>3</td>
</tr>
<tr>
<td>'e'</td>
<td>4</td>
</tr>
<tr>
<td>'p'</td>
<td>2</td>
</tr>
<tr>
<td>' '</td>
<td>2</td>
</tr>
<tr>
<td>'o'</td>
<td>2</td>
</tr>
<tr>
<td>'r'</td>
<td>1</td>
</tr>
<tr>
<td>'!'</td>
<td>1</td>
</tr>
</tbody></table><br>
<br>
После вычисления частот мы создадим узлы бинарного дерева для каждого 
знака и добавим их в очередь, используя частоту в качестве приоритета:<br>

<table border="1">
  <tr>
    <td>1</td>
    <td>1</td>
    <td>2</td>
    <td>2</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
  </tr>
  <tr>
    <td>r</td>
    <td>!</td>
    <td>p</td>
    <td>o</td>
    <td>_</td>
    <td>b</td>
    <td>e</td>
  </tr>
</table>
<br>
Теперь мы достаём два первых элемента из очереди и связываем их, 
создавая новый узел дерева, в котором они оба будут потомками, а 
приоритет нового узла будет равен сумме их приоритетов. После этого мы 
добавим получившийся новый узел обратно в очередь.<br>
<table border="1">
  <tr>
    <td>2</td>
    <td>2</td>
    <td>2</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
  </tr>
  <tr>
    <td>*1</td>
    <td>p</td>
    <td>o</td>
    <td>_</td>
    <td>b</td>
    <td>e</td>
  </tr>
</table>
<br>
Повторим те же шаги и получим последовательно:<br>
<table border="1">
  <tr>
    <td>2</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>4</td>
  </tr>
  <tr>
    <td>o</td>
    <td>_</td>
    <td>b</td>
    <td>*2</td>
    <td>e</td>
  </tr>
</table>
<br>
<table border="1">
  <tr>
    <td>3</td>
    <td>4</td>
    <td>4</td>
    <td>4</td>
  </tr>
  <tr>
    <td>b</td>
    <td>*3</td>
    <td>*2</td>
    <td>e</td>
  </tr>
</table>
<br>
<table border="1">
  <tr>
    <td>4</td>
    <td>4</td>
    <td>7</td>
  </tr>
  <tr>
    <td>*2</td>
    <td>e</td>
    <td>*4</td>
  </tr>
</table>
<br>
<table border="1">
  <tr>
    <td>7</td>
    <td>8</td>
  </tr>
  <tr>
    <td>*4</td>
    <td>*5</td>
  </tr>
</table>
<br>
 Ну и после того, как мы свяжем два последних элемента, получится итоговое дерево.<br>
 <br>
<br>
Теперь, чтобы получить код для каждого символа, надо просто пройтись по 
дереву, и для каждого перехода добавлять 0, если мы идём влево, и 1 — 
если направо.<br>
<br>
 Если мы так сделаем, то получим следующие коды для символов:<br>
<table>
<tbody><tr>
<th>Символ</th>
<th>Код</th>
</tr>
<tr>
<td>'b'</td>
<td>00</td>
</tr>
<tr>
<td>'e'</td>
<td>11</td>
</tr>
<tr>
<td>'p'</td>
<td>101</td>
</tr>
<tr>
<td>' '</td>
<td>011</td>
</tr>
<tr>
<td>'o'</td>
<td>010</td>
</tr>
<tr>
<td>'r'</td>
<td>1000</td>
</tr>
<tr>
<td>'!'</td>
<td>1001</td>
</tr>
</tbody></table><br>
<br>
Чтобы расшифровать закодированную строку, нам надо, соответственно, 
просто идти по дереву, сворачивая в соответствующую каждому биту сторону
 до тех пор, пока мы не достигнем листа. Например, если есть строка «101
 11 101 11» и наше дерево, то мы получим строку «pepe».<br>
<br>
Важно иметь в виду, что каждый код не является префиксом для кода 
другого символа. В нашем примере, если 00 — это код для 'b', то 000 не 
может оказаться чьим-либо кодом, потому что иначе мы получим конфликт. 
Мы никогда не достигли бы этого символа в дереве, так как 
останавливались бы ещё на 'b'.<br>
<br>
На практике, при реализации данного алгоритма сразу после построения 
дерева строится таблица Хаффмана. Данная таблица — это по сути связный 
список или массив, который содержит каждый символ и его код, потому что 
это делает кодирование более эффективным. Довольно затратно каждый раз 
искать символ и одновременно вычислять его код, так как мы не знаем, где
 он находится, и придётся обходить всё дерево целиком. Как правило, для 
кодирования используется таблица Хаффмана, а для декодирования — дерево 
Хаффмана.<br>
<br>
Входная строка: «beep boop beer!»<br>
Входная строка в бинарном виде: «0110 0010 0110 0101 0110 0101 0111 0000
 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 
0110 0101 0110 0101 0111 0010 0010 000»<br>
Закодированная строка: «0011 1110 1011 0001 0010 1010 1100 1111 1000 1001»<br>
Как вы можете заметить, между ASCII-версией строки и закодированной версией существует большая разница.<br>

</div>
</body>
</html>
